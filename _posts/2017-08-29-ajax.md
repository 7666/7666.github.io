---
layout: post
title:  "AJAX"
date:   2017-08-29 08:16:54
categories: AJAX
tags: AJAX
---

* content
{:toc}

AJAX即'Asynchronous Javascript And XML'(异步JavaScript和XML),是指一种创建交互式网页应用的网页开发技术.  

AJAX = 异步 JavaScript和XML(标准通用标记语言的子集).  
AJAX是一种用于创建快速动态网页的技术.  
AJAX是一种在无需重新加载整个页面的情况下,能够更新部分网页的技术.通过在后台与服务器进行少量数据交换,AJAX可以使网页实现异步更新.这意味着可以在不重新加载整个网页的情况下,对网页的某部分进行更新.   
传统的网页(不使用AJAX)如果需要更新内容,必须重载整个网页页面.




## AJAX技术

AJAX技术的核心是XMLHttpRequest对象(简称 XHR),XHR为向服务器发送请求和解析服务器想赢提供了流畅的借口.能够以异步方式从服务器取得更多信息,意味着用户单击后,可以不必刷新页面也可以取得新数据,也就是说,可以使用XHR对象取得新数据,然后再通过DOM将新数据插入到页面中.另外,虽然名字中包含XML的成分,但AJAX通信与数据格式无关;这种技术就是无需刷新页面即可从服务器取得数据,但不一定是XML数据.

* 定义： ajax是用于客户端和服务端进行异步数据交互，在无需刷新整个页面的情况下实现局部数据更新的一种技术。
* 特点： 前后端通信，异步方式通信，无刷新，局部更新。

优点:

1. 最大的一点是页面无刷新，用户的体验非常好。
2. 使用异步方式与服务器通信，具有更加迅速的响应能力。
3. 可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。
4. 基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。

缺点:

1. ajax不支持浏览器back按钮。
2. 安全问题 AJAX暴露了与服务器交互的细节。
3. 对搜索引擎的支持比较弱。
4. 破坏了程序的异常机制。
5. 不容易调试。


## 原生XHR对象应用

### 创建XMLHttpRequest对象

```
// 兼容低版本ie浏览器的代码,对于现代浏览器可以省略部分代码
function createXHR(){
    if (typeof XMLHttpRequest != "undefined"){
        return new XMLHttpRequest();
    } else if (typeof ActiveXObject != "undefined"){
         if (typeof arguments.callee.activeXString != "string"){
            var versions = [ "MSXML2.XMLHttp.6.0", "MSXML2.XMLHttp.3.0",
            "MSXML2.XMLHttp"], i, len;
            for (i=0,len=versions.length; i < len; i++){
                try {
                    new ActiveXObject(versions[i]);
                    arguments.callee.activeXString = versions[i];
                    break;
                } catch (ex){
                    //跳过
                }
            }
        }
        return new ActiveXObject(arguments.callee.activeXString);
     } else {
            throw new Error("No XHR object available.");
    }
}
```

上面大堆的代码仅仅是为了兼容低版本的IE浏览器,对于现代的大部分浏览器而言,上面的大部分代码都是冗余的,只需要几行代码,如下:

```
function createXHR(){
  return new XMLHttpRequest();
}
```

上面分别是老版本的IE浏览器和现在浏览器的创建函数.   
现在需要调用这个函数生成一个实例化对象.

```
var xhr = createXHR();
```

当然对于现在大部分浏览器而言,上面的两个步骤可以缩减为一个步骤:

```
var xhr = new XMLHttpRequest();
```

`XMLHttpRequest()`构造函数,初始化一个XMLHttpRequest对象,必须在所有其他方法被调用前调用构造函数.此处用于AJAX通信.

### open() 初始化一个请求

使用XHR对象时,要调用的第一个方法就是`open()`,初始化一个请求,方法用于JAVAScript代码中,这个方法有以下参数

```
void open(
   DOMString method,
   DOMString url,
   optional boolean async,
   optional DOMString user,
   optional DOMString password
);
```

参数:   

- method:请求所使用的HTTP方法,例如:'GET','POST'等.
- url:该请求所要访问的URL
- async:一个可选的布尔值参数,默认为true,意味着是否执行异步操作,如果值为false,则send()方法不会返回任何东西,直到接受到了服务器的返回数据.
- user:可选参数,为授权使用;默认参数为空String.
- password:可选参数,为授权使用;默认参数为空String.

> 对于这个方法,我们只需要前面的3个参数,关于代码:
一是URL相对于执行代码的当前页面(当然也可以使用绝对路径);
二是调用open()方法并不会真正的发送请求,而只是启动一个请求以备发送
三是关于第三个参数异步,异步：客户端发送请求之后，不用死等服务端的响应，可以继续先做自己的事。服务端什么时候响应，那客户端就什么时候接收响应。

### send() 发送一个请求

发送请求.如果该请求是异步模式(默认),该方法会立即返回.相反,如果请求是同步模式,则直到请求的响应完全接受以后,该方法才会返回.   
XMLHttpRequest.send()接受一个可选的参数,其作为请求主体,如果请求方法是GET,其数据携带在URL上,则应将请求主体设置为null.

### 接受响应

在收到响应后,响应的数据会自动填充XHR对象的属性,相关属性简介如下:   
`onreadystatechange`:一个JAVAScript函数对象,当`readyState`属性改变时调用它.
`readyState`:见下.    
`responseText`:作为响应的主体被返回的文本.   
`reponseXML`:如果响应的内容类型是`text/xml`或`application/xml`,这个属性中保存包含着响应数据的XML DOM文档.    
`status`:响应的HTTP状态.
`statusTest`:HTTP状态说明.    

多数情况下,我们还是要发送异步请求,才能让JAVAScript继续执行下去而不必等待响应.此时,我们可以检测XHR对象的readyState属性,该属性表示请求响应过程的当前活动阶段.这个属性可取的值如下:

- 0:未初始化.尚未调用open()方法.
- 1:启动.已经调用open()方法.
- 2:发送.已经调用send()方法,但尚未接收到响应.
- 3:接受.已经接收到部分响应数据.
- 4:完成.已经接受到全部响应数据,而且已经可以在客户端使用了.
- 只要readyState属性的值由一个值变成另外一个值,都会触发一次readystatechange事件.

```
$("#start").click(function(){

      //1. 想要使用ajax，必须要先创建xhr对象
      //此处的xhr用于ajax通信
      var xhr = createXHR();

      //高版本浏览器
      // var xhr = new XMLHttpRequest();

      //2. 准备向服务器发送一次http请求(get, post)
      /*
      true表示是异步请求
      异步：客户端发送请求之后，不用死等服务端的响应，可以继续先做自己的事。
      服务端什么时候响应，那客户端就什么时候接收响应。
      */

      //数据格式  url?key=value&key=value
      xhr.open("get", "http://127.0.0.1:8000/index?name=张三&age=22&score=88", true);

      //用于转码用的
      // console.log(encodeURIComponent("张三 李四 xxx yyy ))) * /~skjkjh"));

      //4. 用于时刻准备接受服务端的响应
      xhr.onreadystatechange = function () {
        // console.log("当前状态： " + xhr.readyState);

        //当状态为4时，表示响应完成， 失败？成功？
        if (xhr.readyState === 4){
          if ((xhr.status >= 200) && (xhr.status < 400)){

            //通过xhr.response得到后端发送来的数据
            console.log("recv from server: ", xhr.response);

            $("<h1>success</h1>").appendTo("body");
          } else {
            $("<h1>fail</h1>").appendTo("body");
          }
        }
      };

      //3. 真正发送一次请求
      //get请求，数据携带在url上，所有send为空即可
      xhr.send();
      $("<h1>send完毕!</h1>").appendTo("body");
    });
```

### GET请求

上面的代码就是一次完整的GET请求    
GET是最常见的请求类型,最常用于向服务器查询某些信息.必要时,可以将查询字符串参数追加到URL的末尾,以便将信息发送给服务器.对XHR而言,位于传入open()方法的URL末尾的查询字符串必须经过正确的编码才行.    
`encodeURLComponent()`是对统一资源标示符(URL)的组成部分进行编码的方法.它使用一到四个转义序列来表示字符串中的的每个字符的UTF-8编码.它会转义除了字母,数字,`(`,`)`,`.`,`!`,`~`,`*`,`'`,`-`和`_`之外的所有字符.     
为了避免服务器收到不可预计的请求,对任何用户输入的作为URL部分的内容你都需要用`encodeURLComponent`进行转义.比如,一个用户可能会输入`Teyme &time=again`作为comment变量的一部分.如果不使用`encodeURLComponent`对此内容进行转义,服务器得到的将是`commnet=Teyme%20&time=again`.请注意,`&`符号和`=`符号产生了一个新的键值对,所以服务器将得到两个键值对(一个键值对是comment=Teyme另一个则是time=again),而不是一个键值对.

### POST请求

使用频率仅次于GET的是POST请求,通常用于向服务器发送应该被保存的数据.POST请求应该把数据作为主体提交,而GET请求传统上不是这样的.POST请求的主体可以包含非常多的数据,而且格式不限.    
默认情况下,服务器对POST请求和提交Web表单的请求并不会一视同仁.因此,服务器端必须有程序来读取发送过来的原始数据,并从中解析出有用的部分.不过,我们可以使用XHR来模仿表单提交:首先将Content-Type头部信息设置为 `application/x-www-form-urlencoded`,也就是表单提交时的内容类型,其次是以适当的格式创建一个字符串.

```
//发送post数据时，按照form表单的数据格式进行发送
//需要设置http的头部来指定要发送的数据格式
xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");

xhr.send("name=lisi&age=22&score=88");
```

由于,POSt请求不是通过URL实现的,所以URL也不必携带参数,完整的一次post请求如下:

```
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>ajax使用的基本步骤</title>
  </head>
  <body>


    <button id="start">ajax</button>

    <script src="./js/jquery.min.js" charset="utf-8"></script>
    <script>

    // 兼容低版本ie浏览器的代码,对于现代浏览器可以省略部分代码
    function createXHR(){
      if (typeof XMLHttpRequest != "undefined"){
        return new XMLHttpRequest();
      } else if (typeof ActiveXObject != "undefined"){
        if (typeof arguments.callee.activeXString != "string"){
          var versions = [ "MSXML2.XMLHttp.6.0", "MSXML2.XMLHttp.3.0",
          "MSXML2.XMLHttp"], i, len;
          for (i=0,len=versions.length; i < len; i++){
            try {
              new ActiveXObject(versions[i]);
              arguments.callee.activeXString = versions[i];
              break;
            } catch (ex){
              //跳过
            }
          }
        }
        return new ActiveXObject(arguments.callee.activeXString);
      } else {
        throw new Error("No XHR object available.");
      }
    }

    $("#start").click(function(){

      //1. 想要使用ajax，必须要先创建xhr对象
      //此处的xhr用于ajax通信
      var xhr = createXHR();

      //高版本浏览器
      // var xhr = new XMLHttpRequest();

      //2. 准备向服务器发送一次http请求(get, post)
      /*
      true表示是异步请求
      异步：客户端发送请求之后，不用死等服务端的响应，可以继续先做自己的事。
      服务端什么时候响应，那客户端就什么时候接收响应。
      */

      xhr.open("post", "http://127.0.0.1:8000/index", true);

      //4. 用于时刻准备接受服务端的响应
      xhr.onreadystatechange = function () {
        // console.log("当前状态： " + xhr.readyState);

        //当状态为4时，表示响应完成， 失败？成功？
        if (xhr.readyState === 4){
          if ((xhr.status >= 200) && (xhr.status < 400)){
            $("<h1>success</h1>").appendTo("body");
          } else {
            $("<h1>fail</h1>").appendTo("body");
          }
        }
      };

      //3. 真正发送一次请求
      //post请求，数据应该在send中发送！！！！！

      //发送post数据时，按照form表单的数据格式进行发送
      //需要设置http的头部来指定要发送的数据格式
      xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");

      xhr.send("name=lisi&age=22&score=88");

      $("<h1>send完毕!</h1>").appendTo("body");
    });

    </script>


  </body>
</html>
```
