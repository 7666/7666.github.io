---
layout: post
title:  "java 抽象类的定义以及使用"
date:   2018-03-08 17:16:54
categories: JAVA
tags: JAVA
---

* content
{:toc}

【90%的正规代码】在以后所有你进行的项目开发之中，绝对不要出现一个类去继承一个抽已经实现好的类，而只能继承我们的抽象类以及接口。

对象的多态性在于我们的一个方法的覆写，那么如果说现在子类没有去进行指定方法的覆写，这样的操作就有些不合乎要求的。所以如果要对子类的方法进行一些强制的要求就必须采用抽象类来解决。





# 抽象类的基本概念

抽象类只是在普通类的基础上扩充了一些抽象方法而已。所谓的抽象方法指的 是只是盛名而未实现（没有方法体），的方法。所有的抽象方法必须使用我们的abstract关键字来进行定义，并且抽象方法所在的类也一定要使用abstract定义类，表示抽象类。

范例：定义一个抽象类

```
package Abstract;

abstract class A{
    private String msg = "helloworld";  //属性
    public void print(){ //普通方法
        System.out.println(this.msg);
    }
    //{}为方法体，所有抽象方法上是不包含有方法体的
    public abstract void fun();//抽象方法
}
public class Demo1 {
    public static void main(String args[]){

    }
}
```   

现在可以发现抽象类就是比普通类多了一些抽象方法而已。

抽象类中包含有抽象方法，而抽象方法与普通方法最大的区别在于其没有方法体 ，即：不知道具体的实现，而如果现在产生了实例化对象，则意味着可以调用类中的所有操作。

对于抽象类的使用的原则：

- 所有的抽象类必须要有子类；
- 抽象类的子类（不是抽象类）必须覆写抽象类中的全部方法；

>方法覆写一定要考虑到权限问题：抽象方法可以使用任意权限，要求权限尽量都用public

- 抽象类的对象可以通过对象多态性，利用子类为其实例化；                                                                  


范例：使用抽象类

```
package Abstract;

abstract class A{
    private String msg = "helloworld";  //属性
    public void print(){ //普通方法
        System.out.println(this.msg);
    }
    //{}为方法体，所有抽象方法上是不包含有方法体的
    public abstract void fun();//抽象方法
}
//一个子类只能够利用extends来继承抽象类，所以依然存在单继承局限
class B extends A{//定义抽象类的子类
    public void fun(){
        System.out.println("Hello");
    }
}
public class Demo1 {
    public static void main(String args[]){
        A a = new B();//实例化子类对象
        a.fun();   //被子类覆写过的方法
    }
}
```

从正常的开发角度来讲，以上的操作没有任何的问题，而且也是一种使用最多的形式，但是对于抽象类必须有一点说明，你以后可能会见到以下的一种使用形式。

```
package Abstract;

abstract class A{
    private String msg = "helloworld";  //属性
    public static A getInstance(){
      class B extends A{//定义抽象类的子类(内部类)
          public void fun(){
              System.out.println("Hello");
          }
      }
      return new B();
    }
    public void print(){ //普通方法
        System.out.println(this.msg);
    }
    //{}为方法体，所有抽象方法上是不包含有方法体的
    public abstract void fun();//抽象方法
}

public class Demo1 {
    public static void main(String args[]){
        A a = A.getInstance();
        a.fun();   
    }
}
```

此类模式属于非正常模式，但是对于一些封装性是有好处的。

# 抽象类的相关规定

1. 抽象类只是比普通方法多了一些抽象方法的定义而已，所以在抽象类当中依然允许有提供有构造方法并且子类也会遵守子类对象的实例化流程。实例化子类对象前一定要先去调用父类的构造方法。

范例：在抽象类中定义构造

```
package Abstract;
abstract class Person{
     private String name;
     private int age;
     public Person(){
         System.out.println("++++++++++++++");
     }
     public abstract String getInfo();//抽象方法
}

class Student extends Person{
    private String school;
    public Student(){
        System.out.println("**************");
    }
    public String getInfo(){
        return null;
    }
}

public class Demo2 {
    public static void main(String args[]){
        new Student();
    }
}
```

如果说现在父类中没有无参构造，那么子类就必须通过super()指明要调用的父类构造方法。

```
package Abstract;
abstract class Person{
     private String name;
     private int age;
     public Person(String name,int age){
         this.name = name;
         this.age = age;
     }
     public String getName(){
         return this.name;
     }
     public int getAge(){
         return this.age;
     }
     public abstract String getInfo();//抽象方法
}

class Student extends Person{
    private String school;
    public Student(String name,int age,String school){
        super(name,age);
        this.school = school;
    }
    public String getInfo(){
        return "name = "+super.getName()+",age = "+super.getAge()+",school = " + this.school;
    }
}

public class Demo2 {
    public static void main(String args[]){
        Person per = new Student("张三",18,"实验一中");
        System.out.println(per.getInfo());
    }
}
```

其实抽象类中存在有我们的构造方法也很好理解，毕竟抽象类中还有属性，所有的属性都一定要在对象实例化的时候进行空间的开辟，那么对象的实例化必须要使用构造方法。
